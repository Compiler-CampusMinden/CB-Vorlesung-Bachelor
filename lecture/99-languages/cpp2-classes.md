# C++: Klassen

> [!IMPORTANT]
>
> <details open>
>
> <summary><strong>üéØ TL;DR</strong></summary>
>
> Klassen werden in C++ mit dem Schl√ºsselwort `class` definiert. Dabei
> m√ºssen Klassendefinitionen immer mit einem Semikolon abgeschlossen
> werden(!). Bei Trennung von Deklaration und Implementierung muss die
> Definition der Methoden mit dem Namen der Klasse als Namespace
> erfolgen:
>
> ``` cpp
> // .h
> class Fluppie {
> public:
>     int wuppie(int c=0);
> };
>
> // .cpp
> int Fluppie::wuppie(int c) { ... }
> ```
>
> Die Sichtbarkeiten f√ºr die Attribute und Methoden werden blockweise
> definiert. F√ºr die Klassen selbst gibt es keine Einstellungen f√ºr die
> Sichtbarkeit.
>
> Objekt-Layout: Die Daten (Attribute) liegen direkt im Objekt
> (anderenfalls Pointer nutzen). Sofern der Typ der Attribute eine
> Klasse ist, kann man diese Attribute nicht mit `NULL` initialisieren
> (kein Pointer, keine Referenz).
>
> F√ºr den Aufruf eines Konstruktors ist kein `new` notwendig, es sei
> denn, man m√∂chte das neue Objekt auf dem Heap haben (inkl. Pointer auf
> das Objekt).
>
> Beachten Sie den Unterschied der Initialisierung der Attribute bei
> einer Initialisierung im Body des Konstruktors vs.¬†der Initialisierung
> √ºber eine **Initialisierungsliste**. (Nutzen Sie in C++ nach
> M√∂glichkeit Initialisierungslisten.)
> </details>

> [!TIP]
>
> <details open>
>
> <summary><strong>üé¶ Videos</strong></summary>
>
> - [VL C++: Klassen](https://youtu.be/4xAYFHWvBGc)
>
> </details>

## OOP in C++

``` java
public abstract class Dummy {
    public Dummy(int v) { value = v; }
    public abstract int myMethod();

    private int value;
}
```

``` cpp
class Dummy {
public:
    Dummy(int v = 0);
    int myMethod();
    virtual ~Dummy();
private:
    int value;
};
```

### OOP in C++: Unterschiede zu Java

- Klassendefinition muss mit Semikolon beendet werden
- Sichtbarkeit wird immer blockweise eingestellt (per Default immer
  `private`)
- Wie bei Funktionen: Deklaration muss vor Verwendung (= Aufruf) bekannt
  sein
- `this` ist keine Referenz, sondern ein **Pointer** auf das eigene
  Objekt

### Objektlayout: Java vs.¬†C++

#### Java: Referenzen auf Objekte

``` java
class Student {
    String name;
    Date birthday;
    double credits;
}
```

<picture><source media="(prefers-color-scheme: light)" srcset="images/objektLayoutJava_light.png"><source media="(prefers-color-scheme: dark)" srcset="images/objektLayoutJava_dark.png"><img src="images/objektLayoutJava.png"></picture>

In Java werden im Objektlayout lediglich die primitiven Attribute direkt
gespeichert.

F√ºr Objekte wird nur eine Referenz auf die Objekte gehalten. Die
Attribute selbst liegen aber au√üerhalb der Klasse, dadurch ben√∂tigt das
Objekt selbst nur relativ wenig Platz im Speicher.

#### C++: Alles direkt im Objekt

``` cpp
class Student {
    string name;
    Date birthday;
    double credits;
};
```

<picture><source media="(prefers-color-scheme: light)" srcset="images/objektLayoutCpp_light.png"><source media="(prefers-color-scheme: dark)" srcset="images/objektLayoutCpp_dark.png"><img src="images/objektLayoutCpp.png"></picture>

In C++ werden alle Attribute innerhalb des Objektlayouts gespeichert.
Ein Objekt mit vielen oder gro√üen Feldern braucht also auch entsprechend
viel Platz im Speicher.

Wollte man eine Java-√§hnliche L√∂sung aufbauen, m√ºsste man in C++
entsprechend Pointer einsetzen:

``` cpp
class Student {
private:
    string *name;
    Date *birthday;
    double credits;
}
```

**Warum nicht Referenzen?**

## Objekte erzeugen mit Konstruktoren

``` cpp
class Dummy {
public:
    Dummy(int c=0) { credits = c; }
private:
    int credits;
};
```

**Erzeugen neuer Objekte**:

``` cpp
Dummy a;
Dummy b(37);
Dummy c=99;
```

**=\> Kein Aufruf von `new`!**

(`new` w√ºrde zwar auch ein neues Objekt anlegen, aber **auf dem Heap**!)

## Default-Konstruktoren

Der C++-Compiler generiert einen **parameterlosen Defaultkonstruktor** -
sofern man nicht selbst mindestens einen Konstruktor definiert.

Dieser parameterlose Defaultkonstruktor wendet f√ºr jedes Attribut dessen
parameterlosen Konstruktor an, f√ºr primitive Typen erfolgt keine
garantierte Initialisierung!

**Achtung**: Default-Konstruktor wird ohne Klammern aufgerufen!

``` cpp
Dummy a;    // Korrekt
Dummy a();  // FALSCH!!! (Deklaration einer Funktion `a()`, die ein `Dummy` zurueckliefert)
```

## C++: Trennung .h und .cpp

``` cpp
// .h
class Dummy {
public:
    Dummy(int c=0);
private:
    int credits;
};
```

``` cpp
// .cpp
Dummy::Dummy(int c) {
    credits = c;
}
```

Klassenname ist der Scope f√ºr die Methoden

## Konstruktoren: Normale (Java-like) Initialisierung

``` cpp
class Student {
public:
    Student(const string &n, const Date &d, double c) {
        name = n;
        birthday = d;
        credits = c;
    }
private:
    string name;
    Date birthday;
    double credits;
};
```

Hier erfolgt die Initialisierung in **zwei** Schritten:

1.  Attribut wird angelegt und mit Defaultwert/-konstruktor des
    Datentyps initialisiert
2.  Anschlie√üend wird die Zuweisung im Body des Konstruktors ausgef√ºhrt

Das klappt nat√ºrlich nur, wenn es einen parameterlosen Konstruktor f√ºr
das Attribut gibt.

Beispiel oben: Beim Anlegen von `birthday` im Speicher wird der
**Defaultkonstruktor** f√ºr `Date` aufgerufen. Danach wird im Body der
√ºbergebene Datumswert **zugewiesen**.

<p align="right"><a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/lecture/99-languages/src/studiInitBody.cpp">Konsole: studiInitBody.cpp</a></p>

## Konstruktoren: Initialisierungslisten

``` cpp
class Student {
public:
    Student(const string &n, const Date &d, double c)
    : name(n), birthday(d), credits(c)
    {}
private:
    string name;
    Date birthday;
    double credits;
};
```

In diesem Fall erfolgt die Initialisierung in nur einem Schritt:

1.  Attribut wird angelegt und direkt mit √ºbergebenen Wert (Kopie)
    initialisiert

Das klappt nat√ºrlich nur, wenn ein passender Konstruktor f√ºr das
Attribut existiert.

**Achtung**: Die Reihenfolge der Auswertung der Initialisierungslisten
wird durch die Reihenfolge der Attribut-Deklarationen in der Klasse
bestimmt!!!

Beispiel oben: Beim Anlegen von `birthday` im Speicher wird direkt der
√ºbergebene Wert **kopiert**.

<p align="right"><a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Bachelor/blob/master/lecture/99-languages/src/studiInitListe.cpp">Konsole: studiInitListe.cpp (ohne/mit -Wall)</a></p>

## Zwang zu Initialisierungslisten

In manchen F√§llen **muss** man die Initialisierung der Attribute per
Initialisierungsliste durchf√ºhren.

Hier einige Beispiele:

- Attribut **ohne parameterfreien Konstruktor**

  Bei ‚Äúnormaler‚Äù Initialisierung w√ºrde zun√§chst der parameterfreie
  Konstruktor f√ºr das Attribut aufgerufen, bevor der Wert zugewiesen
  wird. Wenn es keinen parameterfreien Konstruktor f√ºr das Attribut
  gibt, bekommt man beim Kompilieren einen Fehler.

- **Konstante** Attribute

  Bei ‚Äúnormaler‚Äù Initialisierung w√ºrde das Attribut zun√§chst per
  parameterfreiem Konstruktor angelegt (s.o.), danach existiert es und
  ist konstant und darf nicht mehr ge√§ndert werden (m√ºsste es aber, um
  die eigentlich gew√ºnschten Werte im Body zu setzen) ‚Ä¶

- Attribute, die **Referenzen** sind

  Referenzen m√ºssen direkt beim Anlegen initialisiert werden.

## C++11 und delegierende Konstruktoren

``` cpp
class C {
    // 1: Normaler Konstruktor
    C(int x) { }

    // 2: Delegiert zu (1)
    C() : C(42) { }

    // 3: Rekursion mit (4)
    C(char c) : C(42.0) { }

    // 4: Rekursion mit (3)
    C(double d) : C('a') { }
};
```

Delegierende Konstruktoren gibt es ab C++11:

- Vor C++11: Ein Objekt ist fertig konstruiert, wenn der Konstruktor
  durchgelaufen ist
- Ab C++11: Ein Objekt ist fertig konstruiert, wenn der **erste**
  Konstruktor fertig ausgef√ºhrt ist =\> Jeder weitere aufgerufene
  Konstruktor agiert auf einem ‚Äúfertigen‚Äù Objekt.
- Vorsicht mit rekursiven Aufrufen: Compiler *kann* warnen, muss aber
  nicht.

## C++ und explizite Konstruktoren

- Implizite Konvertierung mit einelementigen Konstruktoren:

  ``` cpp
  class Dummy {
  public:
      Dummy(int c=0);
  };

  Dummy a;
  a = 37;     // Zuweisung(!)
  ```

  Auf der linken Seite der Zuweisung steht der Typ `Dummy`, rechts ein
  `int`. Der Compiler sucht nach einem Weg, aus einem `int` einen
  `Dummy` zu machen und hat durch die Gestaltung des Konstruktors von
  `Dummy` diese M√∂glichkeit. D.h. in dieser Zuweisung wird implizit aus
  der 37 ein Objekt vom Typ `Dummy` gebaut (Aufruf des Konstruktors) und
  dann die Zuweisung ausgef√ºhrt.

  Dieses Verhalten ist in vielen F√§llen recht praktisch, kann aber auch
  zu unerwarteten Problemen f√ºhren. Zur Abhilfe gibt es das
  Schl√ºsselwort `explicit`.

<!-- -->

- Falls unerw√ºnscht: Schl√ºsselwort `explicit` nutzen

  ``` cpp
  explicit Dummy(int c=0);
  ```

## Wrap-Up

- Klassendefinition mit Semikolon abschlie√üen (!)
- Sichtbarkeiten blockweise, keine f√ºr Klasse
- Daten liegen direkt im Objekt (anderenfalls Pointer nutzen)
- Attribute sind echte Objekte: Initialisieren mit `NULL` nicht m√∂glich
- Konstruktoren: Kein `new` n√∂tig (w√ºrde Objekt auf Heap anlegen und
  Pointer liefern)

## üìñ Zum Nachlesen

- Breymann ([2011](#ref-Breymann2011))
- ‚ÄûC and C++ Reference‚Äú ([o.¬†J.](#ref-cppreference.com))
- Allain und Hoffer ([o.¬†J.](#ref-cprogramming.com))

> [!NOTE]
>
> <details>
>
> <summary><strong>‚úÖ Lernziele</strong></summary>
>
> - k2: Ich kann den Aufbau von C++-Klassen im Speicher an einem
>   Beispiel erkl√§ren
> - k2: Ich kann die Problematik expliziter Konstruktoren erkl√§ren
> - k2: Ich kann die Problematik mit Defaultkonstruktoren/-operatoren im
>   Zusammenhang mit Pointern erkl√§ren und ein Beispiel angeben
> - k3: Ich kann Konstruktoren definieren und einsetzen (eigene,
>   Default)
> - k3: Ich kenne den Unterschied zw. Initialisierungslisten
>   vs.¬†Initialisierung im Body und kann das in eigenen Programmen
>   einsetzen
>
> </details>

> [!TIP]
>
> <details>
>
> <summary><strong>üèÖ Challenges</strong></summary>
>
> **C++: Klassen**
>
> Erkl√§ren Sie die Unterschiede zwischen den Klassendefinitionen (Java,
> C++):
>
> ``` java
> class Student {
>     private String name;
>     private Date birthday;
>     private double credits;
> }
> ```
>
> ``` cpp
> class Student {
> private:
>     string name;
>     Date birthday;
>     double credits;
> };
> ```
>
> **Konstruktoren**
>
> - Wie kann der implizite Aufruf eines Konstruktors verhindert werden
>   (beispielsweise in `Dummy b; b=3;`)?
> - In welchen F√§llen muss eine Initialisierung von Attributen in der
>   Initialisierungsliste stattfinden?
> - Wie k√∂nnen/m√ºssen `static` Attribute initialisiert werden?
>
> </details>

------------------------------------------------------------------------

> [!NOTE]
>
> <details>
>
> <summary><strong>üëÄ Quellen</strong></summary>
>
> <div id="refs" class="references csl-bib-body hanging-indent">
>
> <div id="ref-cprogramming.com" class="csl-entry">
>
> Allain, A., und A. Hoffer. o.¬†J. ‚ÄûC Programming and C++ Programming‚Äú.
> Zugegriffen 16. September 2024. <https://www.cprogramming.com/>.
>
> </div>
>
> <div id="ref-Breymann2011" class="csl-entry">
>
> Breymann, U. 2011. *Der C++ Programmierer*. 2. Auflage. Hanser.
>
> </div>
>
> <div id="ref-cppreference.com" class="csl-entry">
>
> ‚ÄûC and C++ Reference‚Äú. o.¬†J. Cppreference.com. Zugegriffen 16.
> September 2024. <https://en.cppreference.com/w/>.
>
> </div>
>
> </div>
>
> </details>

------------------------------------------------------------------------

<img src="https://licensebuttons.net/l/by-sa/4.0/88x31.png" width="10%">

Unless otherwise noted, this work is licensed under CC BY-SA 4.0.

<blockquote><p><sup><sub><strong>Last modified:</strong> 8e76968 (lecture: rework outcomes (09/CPP2), 2025-08-21)<br></sub></sup></p></blockquote>
